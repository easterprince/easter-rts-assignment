# easter-rts-assignment

## Быстрый старт

Решение представляет собой решение на движке Unity 2021.2.3f1.

Для сборки проекта в открытом проекте воспользуйтесь оконным меню: "File" -> "Build And Run".

Для запуска собранного исполняемого файла можно использовать аргументы:
- `-async` для того, чтобы прототип использовал дополнительные потоки для распараллеливания игровой логики.
- `-sync` для запрета распараллеливания (не распространяется на встроенные вычисления движка).
- `-units [count]` для указания количества юнитов на карте.

Пример строки для запуска исполняемого файла:
`EasterRTS.exe -async -units 2000`

## Введение

Данный проект представляет собой эксперимент по распараллеливанию вычислений в Unity-проекте.

Для игр, которые задействуют большое количество вычислений на процессоре (например, стратегии), имеет большой смысл распределять вычисления по нескольким потокам. Это, однако, часто является довольно сложной задачей: игры часто имеют сложную архитектуру с тесным взаимодействием между многими элементами, и это затрудняет безопасное и эффективное распараллеливание вычислений. К тому же эти вычисления надо проводить в реальном времени, с каждым обновляющимся кадром.

Задача далее усложняется для проектов на движке Unity, потому что основной игровой цикл обрабатывается по большей части в единственном потоке. Есть поддержка асинхронных вычислений в отдельных потоках ([Job System](https://docs.unity3d.com/Manual/JobSystem.html)), но система накладывает существенные ограничения на проводимые вычисления.

Тем не менее движок позволяет задействовать встроенные средства C# для распараллеливания вычислений.

## Концепт игры

Прототип игры представляет собой карту с некоторым количеством юнитов. Карта разбита на сегменты в форме многоугольников, и юниты могут свободно перемещаться внутри сегментов, а также между сегментами. Потенциально сегменты могут блокировать перемещение, влиять на скорость перемещения, и именть прочие динамически меняющиеся характеристики, влияющие на движение юнитов. У каждого юнита есть изначальная позиция и точка назначения, и его цель - максимально быстро добраться от старта к финишу.

![image](https://user-images.githubusercontent.com/31956404/144747463-f50450af-c572-423f-a7c5-6b528026c35f.png)

Чтобы добраться от стрта к финишу, юнитам нужно рассчитать кратчайший путь по сегментам, которые он может пройти. Поскольку потенциально сегменты могут изменяться, в проекте моделируется ситуация, когда юниту нужно рассчитывать кратчайший путь каждый раз, когда он достигает очередного сегмента. Эти постоянные расчёты и составляют основную "тяжесть" игровой логики в прототипе.

## Архитектура игровой логики

Игровые скрипты написаны на языке C#.

Концептуально вся игровая логика разделяется на две части:
- Модель - описывает игровые сущности, такие как карта и юниты, и моделирует их взаимодействие. Вычисления в модели производятся независимо от интерфейса; реализована модель с помощью обычных C#-классов (классы-ядра `[...]Core`, например `UnitCore`).
- Отображение - игровые объекты Unity и элементы пользовательского интерфейса, который визуализируют модель и позволяют пользователю на неё влиять (классы `[...]Entity` и `[...]View`, например `UnitEntity` и `UnitView`)..

Логику отображения как-то распараллелить сложно или вовсе нельзя, так как она по большей части зависит от игрового цикла самого движка, выполняющегося в одном потоке. Однако логику отдельно вынесенной модели можно распараллелить с помощью средств C#, так как она от этого цикла никак не зависит.

Взаимодействие между классами моделями и их обновление реализовано с помощью системы действий (Actions). Вместо того чтобы напрямую изменять свои свойства, классы собирают нужные изменения в отдельные структуры - действия - и отправляют их в общую очередь действий; позже в едином потоке все эти действия применяются. Например, класс `UnitMovement`, отвечающий за движение конкретного юнита, в ходе обновления рассчитывает новую позицию и скорость юнита через некоторый промежуток времени, согласно найденного пути до пункта назначения, и далее планирует действие `MovementUpdate`, которое обновляет позицию и скорость в конце периода обновления.

Система действий позволяет исключить гонку данных при расчётах игровой логики, которые идут параллельно с рендером кадров и обновлениями интерфейса: все вычисления выполняются внутри классов модели и скрыты извне; все изменения в данных применяются синхронно и единовременно.

![high-concept](https://user-images.githubusercontent.com/31956404/144750519-6c853602-652a-4bc8-a6e6-b83272780f83.png)

Вычисления распараллелены с помощью [системы задач](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming). В рамках задач выполняется планирование действий и помещение их в потокобезопасные очереди. Задачи выполняются в отдельных потоках. Основная часть всего этого процесса реализована в классе `EasterRts.Common.Cores.ModelBase`.

Изначально планировалось создавать задачу под обновление каждого ядра (юнита, движения юнита, и т.д.), но вычисления в каждом конкретном ядре оказались не такими существенными по сравнению с затратами времени на планирование и синхронизацию задач. Процесс был оптимизирован: каждая задача теперь включат в себя вычисления сразу по нескольким ядрам, и в итоге задач получилось намного меньше, но всё равно достаточно для эффективного распределения вычислений по нескольким потокам.

## Результаты распараллеливания

Прототип запускался на ноутбуке с 6-ядерным процессором Intel(R) Core(TM) i7-10750H CPU @ 2.60GHz, на дискретной видеокарте.

В ходе эксперимента 2000 юнитов помещались в случайные точки на карте и единовременно начинали двигаться в случайно выбранные точки назначения. Пользу от распараллеливания было легко отследить по счётчику отображаемых кадров в секунду (FPS).

1. `EasterRTS.exe -sync -units 2000`
Без включённого распараллеливания прототип обновлялся рывками, поскольку вычислений требовалось сделать слишком много, а большинство доступных вирутальных ядер практически не использовалось. FPS не поднимался выше 5.

![image](https://user-images.githubusercontent.com/31956404/144751747-54e64051-4b07-432f-9712-57e2f9369388.png)

![image](https://user-images.githubusercontent.com/31956404/144751853-4a4d8fde-145a-439b-8281-e74591ee6188.png)

2. `EasterRTS.exe -async -units 2000`
Со включённым распараллеливанием прототип обновлялся плавно - вычисления эффективно распределялись по виртуальным ядрам. FPS стабильно составлял выше 60.

![image](https://user-images.githubusercontent.com/31956404/144751931-d683e6df-ab3c-4c32-ad3c-e8d63c45edcb.png)

![image](https://user-images.githubusercontent.com/31956404/144751948-05c5847f-7c44-4188-8790-6e69bd5eadb1.png)

## Заключение

Результаты показали, что эффективное распараллеливание вычислений игровой логики в Unity-проекте возможно и реализуемо. В будущем можно попробовать добавить более тонкую настройку системы задач, либо рассмотреть возможность реализации собственной системы задач на основе потоков, так как текущая реализация не позволяет регулировать количество используемых потоков, возможно, всё ещё тратит значительную часть ресурсов на менеджмент потоков, и т.д. - есть куда развиваться.
